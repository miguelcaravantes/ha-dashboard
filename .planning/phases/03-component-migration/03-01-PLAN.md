---
phase: 03-component-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  [
    src/types/entities.ts,
    src/common/hooks/useEntity.ts,
    src/common/HassContext.tsx,
    src/common/domains.ts,
    src/constants.ts,
    src/App.tsx,
  ]
autonomous: true

must_haves:
  truths:
    - 'Entity IDs have autocomplete and template literal validation'
    - 'Core hooks and context are strictly typed in TS'
    - 'Main App component is converted to TSX with no strict errors'
  artifacts:
    - path: 'src/types/entities.ts'
      provides: 'EntityId and KnownEntityId types'
    - path: 'src/common/hooks/useEntity.ts'
      provides: 'Strictly typed entity access'
  key_links:
    - from: 'src/common/hooks/useEntity.ts'
      to: 'src/types/entities.ts'
      via: 'Type import'
---

<objective>
Establish the strict TypeScript foundation by defining entity types and converting core hooks/context to TSX.
This enables autocomplete for entity IDs and ensures data flowing through the app is strictly typed.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-component-migration/03-RESEARCH.md
@src/common/hooks/useEntity.ts
@src/types/home-assistant.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Entity Types</name>
  <files>src/types/entities.ts</files>
  <action>
    Create src/types/entities.ts.
    Define EntityId as a template literal type: `${string}.${string}`.
    Define KnownEntityId using the (string & {}) trick to allow autocomplete for common domains (light., switch., sensor., binary_sensor., fan.) while still accepting any string.
    Export these types for use in useEntity.
  </action>
  <verify>Check file content for correct template literal type syntax.</verify>
  <done>src/types/entities.ts exists with EntityId and KnownEntityId types.</done>
</task>

<task type="auto">
  <name>Task 2: Strictly Type useEntity Hook</name>
  <files>src/common/hooks/useEntity.ts</files>
  <action>
    Update useEntity.ts to use EntityId for the entityId parameter.
    Remove 'any' types from internal logic (attributes, etc.).
    Properly type the actionTypesMap and getIcon function.
    Ensure stateObj access handles potential undefined states correctly (strict check).
  </action>
  <verify>Run `npx tsc --noEmit` and ensure no errors in useEntity.ts.</verify>
  <done>useEntity.ts is strictly typed and provides autocomplete for entity IDs.</done>
</task>

<task type="auto">
  <name>Task 3: Convert Core Context and App to TSX</name>
  <files>src/common/HassContext.tsx, src/common/domains.ts, src/constants.ts, src/App.tsx</files>
  <action>
    Rename HassContext.js to HassContext.tsx, domains.js to domains.ts, constants.js to constants.ts, and App.jsx to App.tsx.
    Define interfaces for HassContext value.
    Resolve all strict type errors in App.tsx arising from the conversion.
    Ensure imports are updated to reflect file extension changes (using .js suffix for ESM compatibility if required by the project setup, but typically Vite handles this).
  </action>
  <verify>Run `npx tsc --noEmit` and check for errors in these files.</verify>
  <done>App.tsx and core support files are converted to strict TSX/TS.</done>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` to verify that the foundation is sound and there are no type regressions in the converted files.
</verification>

<success_criteria>

- src/types/entities.ts provides valid EntityId types.
- useEntity(entityId) provides autocomplete for entityId.
- App.tsx compiles successfully in strict mode.
  </success_criteria>

<output>
After completion, create `.planning/phases/03-component-migration/03-01-SUMMARY.md`
</output>
